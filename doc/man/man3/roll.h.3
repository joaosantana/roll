.TH "roll.h" 3 "Mon Jun 20 2016" "roll" \" -*- nroff -*-
.ad l
.nh
.SH NAME
roll.h \- The main include file\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <strings\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <getopt\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <limits\&.h>\fP
.br
\fC#include 'config\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBir_node\fP"
.br
.RI "\fInode of the intermediate representation parse tree \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBEXPRESSION_SIZE\fP   1024"
.br
.ti -1c
.RI "#define \fBFALSE\fP   0"
.br
.ti -1c
.RI "#define \fBHUNDRED\fP   \-1"
.br
.ti -1c
.RI "#define \fBOP_DICE\fP   4"
.br
.ti -1c
.RI "#define \fBOP_DIV\fP   3"
.br
.ti -1c
.RI "#define \fBOP_GE\fP   10"
.br
.ti -1c
.RI "#define \fBOP_GT\fP   9"
.br
.ti -1c
.RI "#define \fBOP_HIGH\fP   7"
.br
.ti -1c
.RI "#define \fBOP_LE\fP   12"
.br
.ti -1c
.RI "#define \fBOP_LOW\fP   8"
.br
.ti -1c
.RI "#define \fBOP_LT\fP   11"
.br
.ti -1c
.RI "#define \fBOP_MINUS\fP   6"
.br
.ti -1c
.RI "#define \fBOP_NE\fP   13"
.br
.ti -1c
.RI "#define \fBOP_NUMBER\fP   1"
.br
.ti -1c
.RI "#define \fBOP_PLUS\fP   5"
.br
.ti -1c
.RI "#define \fBOP_REP\fP   14"
.br
.ti -1c
.RI "#define \fBOP_TIMES\fP   2"
.br
.ti -1c
.RI "#define \fBsrandomdev\fP()   srand((unsigned) time(NULL))"
.br
.ti -1c
.RI "#define \fBTRUE\fP   1"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fBir_node\fP * \fBallocate_node\fP (void)"
.br
.RI "\fIAllocates a new IR node\&. \fP"
.ti -1c
.RI "void \fBerror\fP (char *message)"
.br
.RI "\fIPrints the specified error message and exits with a failure status\&. \fP"
.ti -1c
.RI "struct \fBir_node\fP * \fBnew_dice\fP (struct \fBir_node\fP *sides)"
.br
.RI "\fIAllocates a new DICE node\&. \fP"
.ti -1c
.RI "struct \fBir_node\fP * \fBnew_number\fP (int number)"
.br
.RI "\fIAllocates a new NUMBER node\&. \fP"
.ti -1c
.RI "struct \fBir_node\fP * \fBnew_op\fP (unsigned short int op, struct \fBir_node\fP *left, struct \fBir_node\fP *right)"
.br
.RI "\fIAllocates a new OP node\&. \fP"
.ti -1c
.RI "int \fBroll\fP (int dice)"
.br
.RI "\fIRolls an n-sided dice\&. \fP"
.ti -1c
.RI "int \fBroll_expression\fP (struct \fBir_node\fP *node, int print)"
.br
.RI "\fIRoll dices and compute expressions\&. \fP"
.ti -1c
.RI "void \fBusage\fP ()"
.br
.RI "\fIPrints the program's usage\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
The main include file\&. 


.PP
\fBAuthor:\fP
.RS 4
Matteo Corti 
.RE
.PP

.PP
Definition in file \fBroll\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define EXPRESSION_SIZE   1024"

.PP
\fBTodo\fP
.RS 4
The maximum expression length should be dynamic 
.RE
.PP
Maximum expression length 
.PP
Definition at line 40 of file roll\&.h\&.
.PP
Referenced by main()\&.
.SS "#define FALSE   0"
Boolean false 
.PP
Definition at line 33 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define HUNDRED   \-1"
Constant representing a 1d100 rolled with 1d10 for the units and 1d10 for the tens 
.PP
Definition at line 45 of file roll\&.h\&.
.PP
Referenced by roll_dice()\&.
.SS "#define OP_DICE   4"
N-sided dice node 
.PP
Definition at line 83 of file roll\&.h\&.
.PP
Referenced by new_dice(), and roll_expression()\&.
.SS "#define OP_DIV   3"
Integer division node 
.PP
Definition at line 82 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_GE   10"
Keep results greater or equal than 
.PP
Definition at line 89 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_GT   9"
Keep results greater than 
.PP
Definition at line 88 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_HIGH   7"
Keep highest results node 
.PP
Definition at line 86 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_LE   12"
Keep results less or equal than 
.PP
Definition at line 91 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_LOW   8"
Keep lowest resutls node 
.PP
Definition at line 87 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_LT   11"
Keep results less than 
.PP
Definition at line 90 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_MINUS   6"
Subtraction node 
.PP
Definition at line 85 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_NE   13"
Keep results different from 
.PP
Definition at line 92 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_NUMBER   1"
Number node 
.PP
Definition at line 80 of file roll\&.h\&.
.PP
Referenced by new_number(), and roll_expression()\&.
.SS "#define OP_PLUS   5"
Addition node 
.PP
Definition at line 84 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_REP   14"
Number of rolls (repetitions) 
.PP
Definition at line 93 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define OP_TIMES   2"
Multiplication node 
.PP
Definition at line 81 of file roll\&.h\&.
.PP
Referenced by roll_expression()\&.
.SS "#define srandomdev()   srand((unsigned) time(NULL))"
defines srandomdev usig srand of the current time if srandomdev and getpid are missing 
.PP
Definition at line 72 of file roll\&.h\&.
.PP
Referenced by main()\&.
.SS "#define TRUE   1"
Boolean true 
.PP
Definition at line 28 of file roll\&.h\&.
.PP
Referenced by main(), and roll_expression()\&.
.SH "Function Documentation"
.PP 
.SS "struct \fBir_node\fP* allocate_node (void)"

.PP
Allocates a new IR node\&. 
.PP
\fBReturns:\fP
.RS 4
Newly allocated node 
.RE
.PP

.PP
Definition at line 266 of file roll\&.c\&.
.PP
References error(), ir_node::left, ir_node::next, ir_node::op, ir_node::right, and ir_node::value\&.
.PP
Referenced by new_dice(), new_number(), and new_op()\&.
.PP
.nf
266                                          {
267 
268   struct ir_node * node = malloc(sizeof(struct ir_node));
269   if (node == NULL) {
270     error("Out of memory\n");
271     exit(EXIT_FAILURE);
272   }
273 
274   /* initialize default values */
275   node->left  = NULL;
276   node->right = NULL;
277   node->next  = NULL;
278   node->op    = 0;
279   node->value = 0;
280   
281   return node;
282   
283 }
.fi
.SS "void error (char * message)"

.PP
Prints the specified error message and exits with a failure status\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP 
.RE
.PP

.PP
Definition at line 50 of file roll\&.c\&.
.PP
Referenced by allocate_node(), main(), and roll_expression()\&.
.PP
.nf
50                            {
51   fprintf(stderr, "\nError: %s\n", message);
52   exit(EXIT_FAILURE);
53 }
.fi
.SS "struct \fBir_node\fP* new_dice (struct \fBir_node\fP * sides)"

.PP
Allocates a new DICE node\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP 
.RE
.PP

.PP
Definition at line 344 of file roll\&.c\&.
.PP
References allocate_node(), ir_node::op, OP_DICE, ir_node::right, and ir_node::value\&.
.PP
.nf
344                                                     {
345   
346   struct ir_node * node = allocate_node();
347   node->op    = OP_DICE;
348   node->value = 0;
349   node->right = sides;
350   return node;
351   
352 }
.fi
.SS "struct \fBir_node\fP* new_number (int number)"

.PP
Allocates a new NUMBER node\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP 
.RE
.PP

.PP
Definition at line 290 of file roll\&.c\&.
.PP
References allocate_node(), ir_node::op, OP_NUMBER, and ir_node::value\&.
.PP
.nf
290                                            {
291 
292   struct ir_node * node = allocate_node();
293   node->op    = OP_NUMBER;
294   node->value = number;
295 
296   return node;
297 
298 }
.fi
.SS "struct \fBir_node\fP* new_op (unsigned short int op, struct \fBir_node\fP * left, struct \fBir_node\fP * right)"

.PP
Allocates a new OP node\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP 
.RE
.PP

.PP
Definition at line 328 of file roll\&.c\&.
.PP
References allocate_node(), ir_node::left, ir_node::op, ir_node::right, and ir_node::value\&.
.PP
.nf
328                                                                                                 {
329 
330   struct ir_node * node = allocate_node();
331   node->op    = op;
332   node->value = 0;
333   node->left  = left;
334   node->right = right;
335   return node;
336   
337 }
.fi
.SS "int roll (int dice)"

.PP
Rolls an n-sided dice\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP 
.RE
.PP

.PP
Definition at line 124 of file roll\&.c\&.
.PP
Referenced by roll_dice()\&.
.PP
.nf
124                    {
125 
126   /* 
127    * In: W\&. H\&. Press et al,Numerical Recipes in C: The Art of
128    * Scientific Computing\&.  New York, Cambridge University Press,
129    * 1992, 2nd ed\&., p\&. 277
130    *
131    * "If you want to generate a random integer between 1 
132    *  and 10, you should always do it by using high-order
133    *  bits, as in
134    *
135    *  j=1+(int) (10\&.0*rand()/(RAND_MAX+1\&.0));
136    */
137 
138   int res = 1+(int)(((double)dice)*random()/(RAND_MAX+1\&.0));
139 
140   return res;
141 
142 }
.fi
.SS "int roll_expression (struct \fBir_node\fP * node, int print)"

.PP
Roll dices and compute expressions\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP 
.RE
.PP

.PP
Definition at line 376 of file roll\&.c\&.
.PP
References compare(), error(), FALSE, ir_node::left, ir_node::next, ir_node::op, OP_DICE, OP_DIV, OP_GE, OP_GT, OP_HIGH, OP_LE, OP_LOW, OP_LT, OP_MINUS, OP_NE, OP_NUMBER, OP_PLUS, OP_REP, OP_TIMES, ir_node::right, roll_dice(), roll_expression(), TRUE, and ir_node::value\&.
.PP
Referenced by roll_expression()\&.
.PP
.nf
376                                                          {
377 
378   int  high;
379   int  i;
380   int  limit;
381   int  low;
382   int  repetitions;
383   int  return_value = 0;
384   int  sides;
385   int  tmp;
386   int * results;
387 
388   struct ir_node * cur;
389 
390   cur = node;
391   while (cur != NULL) {
392 
393     int sum = 0;
394 
395     switch (cur->op) {
396     
397     case OP_NUMBER:
398       sum = cur->value;
399       break;
400 
401     case OP_REP:
402 
403       for (i = 0; i < roll_expression(cur->left, FALSE); i++) {
404         sum = checked_sum( sum, roll_expression(cur->right, FALSE) );
405       }
406       break;
407       
408     case OP_DICE:
409       sum = roll_dice( roll_expression(cur->right, FALSE) );
410       break;
411       
412     case OP_PLUS:
413       sum = checked_sum( roll_expression( cur->left,  FALSE ),
414                          roll_expression( cur->right, FALSE ) );
415       break;
416       
417     case OP_MINUS:
418       sum = checked_sum( roll_expression( cur->left,  FALSE ),
419                          -roll_expression( cur->right, FALSE ) );
420       break;
421       
422     case OP_TIMES:
423       sum = checked_multiplication( roll_expression( cur->left,  FALSE ),
424                                    roll_expression( cur->right, FALSE ) );
425       break;
426       
427     case OP_DIV:
428       sum = (int)
429         ceil( (float)roll_expression( cur->left,  FALSE ) /
430               roll_expression( cur->right, FALSE ) );
431       break;
432       
433     case OP_HIGH:
434 
435       sides       = roll_expression(cur->right->right->right, FALSE);
436       repetitions = roll_expression(cur->right->left,  FALSE);
437       high        = roll_expression(cur->left, FALSE);      
438 
439       /* array to store the results to sort */
440       if (!(results = malloc(sizeof(int)*repetitions))) {
441         error("Out of memory");
442       }
443       
444       for(i=0; i<repetitions; i++) {
445         results[i] = roll_dice(sides);
446       }
447       qsort(results, repetitions, sizeof(int), &compare);
448 
449       for(i=(repetitions-high); i<repetitions; i++) {
450         sum = checked_sum( sum, results[i] );
451       }
452       
453       free(results);
454       
455       break;
456       
457     case OP_LOW:
458       
459       sides       = roll_expression(cur->right->right->right, FALSE);
460       repetitions = roll_expression(cur->right->left,  FALSE);
461       low         = roll_expression(cur->left, FALSE);
462       
463       if (cur->right->left != NULL) {
464         repetitions = roll_expression(cur->right->left, FALSE);
465       }
466                   
467       /* array to store the results to sort */
468       if (!(results = malloc(sizeof(int)*repetitions))) {
469         error("Out of memory");
470       }
471       
472       for(i=0; i<repetitions; i++) {
473         results[i] = roll_dice(sides);
474       }
475       qsort(results, repetitions, sizeof(int), &compare);
476       for(i=0; i<low; i++) {
477         sum = checked_sum( sum, results[i] );
478       }
479       
480       free(results);
481       
482       break;
483 
484     case OP_GT:
485       
486       limit = roll_expression(cur->right, FALSE);      
487       tmp   = roll_expression(cur->left,  FALSE);
488       while (tmp <= limit) {
489         tmp = roll_expression(cur->left, FALSE);
490       }
491       sum = checked_sum( sum, tmp );
492       
493       break;
494       
495     case OP_GE:
496       
497       limit = roll_expression(cur->right, FALSE);      
498       tmp   = roll_expression(cur->left,  FALSE);
499       while (tmp < limit) {
500         tmp = roll_expression(cur->left, FALSE);
501       }
502       sum = checked_sum( sum, tmp );
503       
504       break;
505       
506     case OP_LT:
507       
508       limit = roll_expression(cur->right, FALSE);      
509       tmp   = roll_expression(cur->left,  FALSE);
510       while (tmp >= limit) {
511         tmp = roll_expression(cur->left, FALSE);
512       }
513       sum = checked_sum( sum, tmp );
514       
515       break;
516       
517     case OP_LE:
518       
519       limit = roll_expression(cur->right, FALSE);      
520       tmp   = roll_expression(cur->left,  FALSE);
521       while (tmp > limit) {
522         tmp = roll_expression(cur->left, FALSE);
523       }
524       sum = checked_sum( sum, tmp );
525       
526       break;
527       
528     case OP_NE:
529       
530       limit = roll_expression(cur->right, FALSE);      
531       tmp   = roll_expression(cur->left,  FALSE);
532       while (tmp == limit) {
533         tmp = roll_expression(cur->left, FALSE);
534       }
535       sum = checked_sum( sum, tmp );
536       
537       break;
538       
539     default :
540       
541       fprintf(stderr, "Implementation error: unkown IR node with code %i\n", cur->op);
542       exit(EXIT_FAILURE);
543       
544     }
545 
546     return_value = checked_sum( return_value, sum);
547     if (print == TRUE) {
548       printf("%i\n", sum);
549     }
550     
551     cur = cur->next;
552     
553   }
554 
555   return return_value;
556   
557 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for roll from the source code\&.
